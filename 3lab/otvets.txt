1. Назначение паттернов поведения?

Паттерны поведения (behavioral patterns) используются для организации, управления и объединения различных вариантов поведения объектов.

2. Нарисуете диаграмму классов и поясните принцип работы паттерна   Chain of responsibility. В  каких случаях надо его применять?

Позволяет обработать запрос нескольким объектам-получателям. 
► Получатели связываются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-то объектом.
Use case:
Объектно-ориентированный связанный список с рекурсивным обходом.
Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся. 
► Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке. 
► Когда набор объектов, способных обработать запрос, должен задаваться динамически.

3. Назначение и принцип организации паттерна Command. Поясните как он связан с конечными автоматами

Паттерн Command преобразовывает запрос на выполнение действия в отдельный объект-команду.
Такая инкапсуляция позволяет передавать эти действия другим функциям и объектам в качестве параметра,
приказывая им выполнить запрошенную операцию, ставить в очередь и логгировать.

4. Как реализовать паттерн Observer?

Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков,
причём издатель не должен вести список подписки самостоятельно.
Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.
Теперь самое интересное. Когда в издателе будет происходить важное событие,
он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков.
Издателю безразлично, какой класс будет иметь тот или иной подписчик,
так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.

5. Нарисуйте диаграмму классов для паттерна  Mediator. Поясните его назначение.
Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой,
благодаря перемещению этих связей в один класс-посредник.

6. В чем разница между паттернами Mediator и Facade?

Фасад создаёт упрощённый интерфейс к подсистеме, классы подсистемы общаются друг с другом напрямую.
Посредник централизует общение между компонентами системы.

7. В чем суть паттерна Memento?  Поясните на примере.

Снимок — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов,
не раскрывая подробностей их реализации.

8. Расскажите о паттерне Visitor?

Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции,
не изменяя классы объектов, над которыми эти операции могут выполняться.

9. В каких случаях надо применять Null object? 

Нулевой объект – это объект с заданным нейтральным поведением,
использование которого позволяет заменить условные операторы (проверки на null) полиморфизмом.
Из интересующего вас класса создайте подкласс, который будет выполнять роль Null-объекта.

В обоих классах создайте метод isNull(), который будет возвращать true для Null-объекта и false для реального класса.
Найдите все места, где код может вернуть null вместо реального объекта. Измените этот код так, чтобы он возвращал Null-объект.
Найдите все места, где переменные реального класса сравниваются с null. Замените такие проверки вызовом метода isNull().

10. Поясните на диаграмме классов как реализовать Strategy.
Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.

11. Перечислите и поясните принципы проектирования SOLID. 

S(The Single Responsibility Principle) - Каждый класс должен иметь одну и только одну причину для изменений.
O(The Open Closed Principle) - «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»
L(The Liskov Substitution Principle) - Наследующий класс должен дополнять, а не изменять базовый.
I(The Interface Segregation Principle) - «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
D(The Dependency Inversion Principle) - «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»